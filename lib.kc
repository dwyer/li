(define (check condition who msg . args)
  (if (not condition)
    (apply error (cons who (cons msg args)))))

(define (print . args)
  (define (iter args)
    (if (not (null? args))
      (begin (display (car args))
             (if (not (null? (cdr args)))
               (begin (display " ")
                      (iter (cdr args)))))))
  (iter args)
  (newline))

(define (randint start end)
  (+ start (modulo (rand) (- end start -1))))

(define (range start end)
  (define (iter k)
    (if (< k end)
      (cons k (iter (+ k 1)))
      nil))
  (iter start))

(define (lcm . args)
  (define (algorithm a b)
    (/ (abs (* a b)) (gcd a b)))
  (cond ((null? args) 1)
        ((null? (cdr args)) (abs (car args)))
        (else
          (apply lcm (cons (algorithm (car args) (cadr args))
                           (cddr args))))))

(define (list-ref lst k)
  (if (= k 0)
    (car lst)
    (list-ref (cdr lst) (- k 1))))

# Taken from R5RS
(define (list-tail lst k)
  (if (zero? k)
    lst
    (list-tail (cdr lst) (- k 1))))

(define (list-ref lst k)
  (car (list-tail lst k)))

# STRINGS

(define (string . chars)
  (apply string->list chars))

(define (string->list str)
  (define (iter k len)
    (if (< k len)
      (cons (string-ref str k)
            (iter (+ k 1) len))
      nil))
  (iter 0 (string-length str)))

(define (list->string lst)
  (define (iter lst str k)
    (if (null? lst)
      str
      (begin (string-set! str k (car lst))
             (iter (cdr lst) str (+ k 1)))))
  (iter lst (make-string (length lst)) 0))

(define (string-append . strs)
  (list->string (apply append (map string->list strs))))

(define (substring str start end)
  (let* ((len (- end start))
         (sub (make-string len)))
    (define (iter k)
      (cond ((< k len)
             (string-set! sub k (string-ref str (+ start k)))
             (iter (+ k 1)))
            (else sub)))
    (iter 0)))

(define (string-copy str)
  (substring str 0 (string-length str)))

# VECTORS

(define (make-vector k . args)
  (if (and (not (null? args)) (not (null? (cdr args))))
    (error `make-vector "too many arguments"))
  (if (or (not (integer? k)) (< k 0))
    (error `make-vector "arg1 must be a positive integer" k))
  (define (make-list k fill)
    (if (= k 0)
      nil
      (cons fill (make-list (- k 1) fill))))
  (list->vector (make-list k (if (null? args) nil (car args)))))

(define (vector->list vec)
  (if (not (vector? vec))
    (error `vector->list "arg must be a vector" vec))
  (define (iter k)
    (if (= k (vector-length vec))
      nil
      (cons (vector-ref vec k) (iter (+ k 1)))))
  (iter 0))

(define (list->vector lst)
  (if (not (list? lst))
    (error `list->vector "arg must be a list" lst))
  (apply vector lst))

(define (vector-fill! vec fill)
  (if (not (vector? vec))
    (error `vector-fill! "arg1 must be a vector" vec))
  (let ((len (vector-length vec)))
    (define (iter k)
      (if (< k len)
        (begin (vector-set! vec k fill)
               (iter (+ k 1)))
        vec))
    (iter 0)))

(define (map proc . args)
  (define (map1 lst)
    (if (null? lst)
      nil
      (cons (proc (car lst))
            (map1 (cdr lst)))))
  (define (iter args)
    (if (or (null? args) (null? (car args)))
      nil
      (cons (apply proc (map car args))
            (iter (map cdr args)))))
  (cond ((null? args) nil)
        ((null? (cdr args))
         (map1 (car args)))
        (else (iter args))))

(define (for-each proc . args)
  (define (for-each-unary lst)
    (if (null? lst)
      nil
      (begin (proc (car lst))
             (for-each-unary (cdr lst)))))
  (define (iter args)
    (if (or (null? args) (null? (car args)))
      nil
      (begin (apply proc (map car args))
             (iter (map cdr args)))))
  (cond ((null? args) nil)
        ((null? (cdr args))
         (for-each-unary (car args)))
        (else (iter args))))
