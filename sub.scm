(define (check condition who msg . args)
  (if (not condition)
    (apply error (cons who (cons msg args)))))

(define (zero? z)
  (check (number? z) 'zero? "not a number" z)
  (= z 0))

(define (positive? x)
  (check (number? x) 'positive? "not a number" x)
  (>= x 0))

(define (negative? x)
  (check (number? x) 'negative? "not a number" x)
  (< x 0))

(define (max x . args)
  (if (null? args)
    x
    (let ((y (car args)))
      (if (and (number? x) (number? y))
        (apply max (cons (if (> x y) x y) (cdr args)))
        (error 'max "arguments must be real numbers" x args)))))

(define (min x . args)
  (if (null? args)
    x
    (let ((y (car args)))
      (if (and (number? x) (number? y))
        (apply min (cons (if (< x y) x y) (cdr args)))
        (error 'min "arguments must be real numbers" x args)))))

(define (abs x)
  (check (number? x) 'abs "not a number" x)
  (if (< x 0)
    (- x)
    x))

(define (lcm . args)
  (define (algorithm a b)
    (/ (abs (* a b)) (gcd a b)))
  (cond ((null? args) 1)
        ((null? (cdr args)) (abs (car args)))
        (else
          (apply lcm (cons (algorithm (car args) (cadr args))
                           (cddr args))))))

(define (reverse lst)
  (define (iter lst tsl)
    (if (null? lst)
      tsl
      (iter (cdr lst)
            (cons (car lst) tsl))))
  (iter lst '()))

; Taken from R5RS
(define (list-tail lst k)
  (if (= k 0)
    lst
    (list-tail (cdr lst) (- k 1))))

(define (list-ref lst k)
  (car (list-tail lst k)))

(define (filter pred? lst)
  (define (iter lst)
    (cond ((null? lst) '())
          ((pred? (car lst))
           (cons (car lst)
                 (iter (cdr lst))))
          (else (iter (cdr lst)))))
  (iter lst))

(define (make-vector k . args)
  (if (and (not (null? args)) (not (null? (cdr args))))
    (error 'make-vector "too many arguments"))
  (if (or (not (integer? k)) (< k 0))
    (error 'make-vector "arg1 must be a positive integer" k))
  (define (make-list k fill)
    (if (= k 0)
      '()
      (cons fill (make-list (- k 1) fill))))
  (list->vector (make-list k (if (null? args) '() (car args)))))

(define (vector->list vec)
  (if (not (vector? vec))
    (error 'vector->list "arg must be a vector" vec))
  (define (iter k)
    (if (= k (vector-length vec))
      '()
      (cons (vector-ref vec k) (iter (+ k 1)))))
  (iter 0))

(define (list->vector lst)
  (if (not (list? lst))
    (error 'list->vector "arg must be a list" lst))
  (apply vector lst))

(define (vector-fill! vec fill)
  (if (not (vector? vec))
    (error 'vector-fill! "arg1 must be a vector" vec))
  (let ((len (vector-length vec)))
    (define (iter k)
      (if (< k len)
        (begin (vector-set! vec k fill)
               (iter (+ k 1)))
        vec))
    (iter 0)))

(define (map proc . args)
  (define (map1 lst)
    (if (null? lst)
      '()
      (cons (proc (car lst))
            (map1 (cdr lst)))))
  (define (iter args)
    (if (or (null? args) (null? (car args)))
      '()
      (cons (apply proc (map car args))
            (iter (map cdr args)))))
  (cond ((null? args) '())
        ((null? (cdr args))
         (map1 (car args)))
        (else (iter args))))

(define (for-each proc . args)
  (define (for-each-unary lst)
    (if (null? lst)
      '()
      (begin (proc (car lst))
             (for-each-unary (cdr lst)))))
  (define (iter args)
    (if (or (null? args) (null? (car args)))
      '()
      (begin (apply proc (map car args))
             (iter (map cdr args)))))
  (cond ((null? args) '())
        ((null? (cdr args))
         (for-each-unary (car args)))
        (else (iter args))))
