(define (check condition who msg . args)
  (if (not condition)
    (apply error (cons who (cons msg args)))))

(define (zero? z)
  (check (number? z) 'zero? "not a number" z)
  (= z 0))

(define (positive? x)
  (check (number? x) 'positive? "not a number" x)
  (>= x 0))

(define (negative? x)
  (check (number? x) 'negative? "not a number" x)
  (< x 0))

(define (max x . args)
  (if (null? args)
    x
    (let ((y (car args)))
      (if (and (number? x) (number? y))
        (apply max (cons (if (> x y) x y) (cdr args)))
        (error 'max "arguments must be real numbers" x args)))))

(define (min x . args)
  (if (null? args)
    x
    (let ((y (car args)))
      (if (and (number? x) (number? y))
        (apply min (cons (if (< x y) x y) (cdr args)))
        (error 'min "arguments must be real numbers" x args)))))

(define (abs x)
  (check (number? x) 'abs "not a number" x)
  (if (< x 0)
    (- x)
    x))

(define (lcm . args)
  (define (algorithm a b)
    (/ (abs (* a b)) (gcd a b)))
  (cond ((null? args) 1)
        ((null? (cdr args)) (abs (car args)))
        (else
          (apply lcm (cons (algorithm (car args) (cadr args))
                           (cddr args))))))

(define (reverse lst)
  (define (iter lst tsl)
    (if (null? lst)
      tsl
      (iter (cdr lst)
            (cons (car lst) tsl))))
  (iter lst '()))

; Taken from R5RS
(define (list-tail lst k)
  (if (= k 0)
    lst
    (list-tail (cdr lst) (- k 1))))

(define (list-ref lst k)
  (car (list-tail lst k)))

(define (__member name pred obj lst)
  (define (iter next)
    (cond ((null? next) #f)
          ((not (pair? next))
           (error name "arg2 must be a list" lst))
          ((pred obj (car next)) next)
          (else (iter (cdr next)))))
  (iter lst))

(define (memq obj lst)
  (__member 'memq eq? obj lst))

(define (memv obj lst)
  (__member 'memv eqv? obj lst))

(define (member obj lst)
  (__member 'member equal? obj lst))

(define (__assoc name pred obj lst)
  (define (iter next)
    (cond ((null? next) #f)
          ((not (and (pair? next) (pair? (car next))))
           (error name "arg2 must be a list of pairs" lst))
          ((pred obj (caar next)) (car next))
          (else (iter (cdr next)))))
  (iter lst))

(define (assq obj lst)
  (__assoc 'assq eq? obj lst))

(define (assv obj lst)
  (__assoc 'assv eqv? obj lst))

(define (assoc obj lst)
  (__assoc 'assoc equal? obj lst))

(define (make-vector k . args)
  (if (and (not (null? args)) (not (null? (cdr args))))
    (error 'make-vector "too many arguments"))
  (if (or (not (integer? k)) (< k 0))
    (error 'make-vector "arg1 must be a positive integer" k))
  (define (make-list k fill)
    (if (= k 0)
      '()
      (cons fill (make-list (- k 1) fill))))
  (list->vector (make-list k (if (null? args) '() (car args)))))

(define (vector->list vec)
  (if (not (vector? vec))
    (error 'vector->list "arg must be a vector" vec))
  (define (iter k)
    (if (= k (vector-length vec))
      '()
      (cons (vector-ref vec k) (iter (+ k 1)))))
  (iter 0))

(define (list->vector lst)
  (if (not (list? lst))
    (error 'list->vector "arg must be a list" lst))
  (apply vector lst))

(define (vector-fill! vec fill)
  (if (not (vector? vec))
    (error 'vector-fill! "arg1 must be a vector" vec))
  (let ((len (vector-length vec)))
    (define (iter k)
      (if (< k len)
        (begin (vector-set! vec k fill)
               (iter (+ k 1)))
        vec))
    (iter 0)))

(define (map proc . args)
  (define (map1 lst)
    (if (null? lst)
      '()
      (cons (proc (car lst))
            (map1 (cdr lst)))))
  (define (iter args)
    (if (or (null? args) (null? (car args)))
      '()
      (cons (apply proc (map car args))
            (iter (map cdr args)))))
  (cond ((null? args) '())
        ((null? (cdr args))
         (map1 (car args)))
        (else (iter args))))

(define (for-each proc . args)
  (define (for-each-unary lst)
    (if (null? lst)
      '()
      (begin (proc (car lst))
             (for-each-unary (cdr lst)))))
  (define (iter args)
    (if (or (null? args) (null? (car args)))
      '()
      (begin (apply proc (map car args))
             (iter (map cdr args)))))
  (cond ((null? args) '())
        ((null? (cdr args))
         (for-each-unary (car args)))
        (else (iter args))))
