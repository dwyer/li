(define (make-timer)
  (let ((start (current-jiffy)))
    (lambda ()
      (inexact (/ (- (current-jiffy)
                     start)
                  (jiffies-per-second))))))

(define timer (make-timer))

(import lib)

(define x 28)
(assert (equal? x 28))
(assert (equal? (quote a) 'a))
(assert (equal? (quote [a b c]) [a b c]))
(assert (equal? (quote (+ 1 2)) '(+ 1 2)))
(assert (equal? 'a 'a))
(assert (equal? '[a b c] [a b c]))
(assert (equal? '() ()))
(assert (equal? '(+ 1 2) (quote (+ 1 2))))
#(assert (equal? '(quote a) (quote a)))
#(assert (equal? ''a (quote a)))
(assert (equal? '"abc" "abc"))
(assert (equal? "abc" "abc"))
(assert (equal? '145932 145932))
(assert (equal? 145932 145932))
(assert (equal? 'true true))
(assert (equal? true true))
(assert (equal? (+ 3 4) 7))
(assert (equal? ((if false + *) 3 4) 12))
#(assert (equal? (lambda (x) (+ x x)) a procedure))
(assert (equal? ((lambda (x) (+ x x)) 4) 8))
(define reverse-subtract
  (lambda (x y) (- y x)))
(assert (equal? (reverse-subtract 7 10) 3))
(define add4
  (let ((x 4))
    (lambda (y) (+ x y))))
(assert (equal? (add4 6) 10))
(assert (equal? ((lambda x x) 3 4 5 6) '(3 4 5 6)))
(assert (equal? ((lambda (x y . z) z)
                 3 4 5 6) '(5 6)))
(assert (equal? (if (> 3 2) 'yes 'no) 'yes))
(assert (equal? (if (> 2 3) 'yes 'no) 'no))
(assert (equal? (if (> 3 2)
                  (- 3 2)
                  (+ 3 2)) 1))
(define x 2)
(assert (equal? (+ x 1) 3))
(assert (equal? (begin (set! x 4) x) 4))
(assert (equal? (+ x 1) 5))
(assert (equal? (cond ((> 3 2) 'greater)
                      ((< 3 2) 'less)) 'greater))
(assert (equal? (cond ((> 3 3) 'greater)
                      ((< 3 3) 'less)
                      (else 'equal)) 'equal))
#(assert (equal? (cond ((assv 'b '((a 1) (b 2))) => cadr)
#                      (else false)) 2))
(assert (equal? (case (* 2 3)
                  ((2 3 5 7) 'prime)
                  ((1 4 6 8 9) 'composite)) 'composite))
(assert (equal? (case (car '(c d))
                  ((a) 'a)
                  ((b) 'b)) false))
(assert (equal? (case (car '(c d))
                  ((a e i o u) 'vowel)
                  ((w y) 'semivowel)
                  (else 'consonant)) 'consonant))
(assert (equal? (and (= 2 2) (> 2 1)) true))
(assert (equal? (and (= 2 2) (< 2 1)) false))
(assert (equal? (and 1 2 'c '(f g)) '(f g)))
(assert (equal? (and) true))
(assert (equal? (or (= 2 2) (> 2 1)) true))
(assert (equal? (or (= 2 2) (< 2 1)) true))
(assert (equal? (or false false false) false))
(assert (equal? (or (memq 'b '(a b c)) 
                    (/ 3 0)) '(b c)))
(assert (equal? (let ((x 2) (y 3))
                  (* x y)) 6))
(assert (equal? (let ((x 2) (y 3))
                  (let ((x 7)
                        (z (+ x y)))
                    (* z x))) 35))
(assert (equal? (let ((x 2) (y 3))
                  (let* ((x 7)
                         (z (+ x y)))
                    (* z x))) 70))
(assert (equal? (letrec ((even?
                           (lambda (n)
                             (if (zero? n)
                               true
                               (odd? (- n 1)))))
                         (odd?
                           (lambda (n)
                             (if (zero? n)
                               false
                               (even? (- n 1))))))
                  (even? 88)) true))
(define x 0)
(assert (equal? (begin (set! x 5)
                       (+ x 1)) 6))
(assert (equal? (begin (display "4 plus 1 equals ")
                       (display (+ 4 1))
                       (newline)) null))
(assert (equal? (do ((vec (make-vector 5))
                     (i 0 (+ i 1)))
                  ((= i 5) vec)
                  (set vec i i)) [0 1 2 3 4]))
(assert (equal? (let ((x '(1 3 5 7 9)))
                  (do ((x x (cdr x))
                       (sum 0 (+ sum (car x))))
                    ((null? x) sum))) 25))
(assert (equal? (let loop ((numbers '(3 -2 1 6 -5))
                           (nonneg '())
                           (neg '()))
                  (cond ((null? numbers) (list nonneg neg))
                        ((>= (car numbers) 0)
                         (loop (cdr numbers)
                               (cons (car numbers) nonneg)
                               neg))
                        ((< (car numbers) 0)
                         (loop (cdr numbers)
                               nonneg
                               (cons (car numbers) neg))))) '((6 1 3) (-5 -2))))
(assert (equal? `(list ,(+ 1 2) 4) '(list 3 4)))
(assert (equal? (let ((name 'a)) `(list ,name ',name)) '(list a (quote a))))
(assert (equal? `(a ,(+ 1 2) ,@(map abs '(4 -5 6)) b) '(a 3 4 5 6 b)))
(assert (equal? `(( foo ,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons))) '((foo 7) . cons)))
#(assert (equal? `[10 5 ,(sqrt 4) ,@(map sqrt '(16 9)) 8] [10 5 2 4 3 8]))
#(assert (equal? `(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f) '(a `(b ,(+ 1 2) ,(foo 4 d) e) f)))
#(assert (equal? (let ((name1 'x)
#                      (name2 'y))
#                  `(a `(b ,,name1 ,',name2 d) e)) '(a `(b ,x ,'y d) e)))
(assert (equal? (quasiquote (list (unquote (+ 1 2)) 4)) '(list 3 4)))
(assert (equal? '(quasiquote (list (unquote (+ 1 2)) 4)) '`(list ,(+ 1 2) 4)))
#(assert (equal? (quasiquote (list (unquote (+ 1 2)) 4))
#                (let-syntax ((when (syntax-rules ()
#                                                 ((when test stmt1 stmt2 ...)
#                                                  (if test
#                                                    (begin stmt1
#                                                           stmt2 ...))))))
#                  (let ((if true))
#                    (when if (set! if 'now))
#                    if)) 'now))
#(assert (equal? (let ((x 'outer))
#                  (let-syntax ((m (syntax-rules () ((m) x))))
#                    (let ((x 'inner))
#                      (m)))) outer))
#(assert (equal? (letrec-syntax
#                  ((my-or (syntax-rules ()
#                                        ((my-or) false)
#                                        ((my-or e) e)
#                                        ((my-or e1 e2 ...)
#                                         (let ((temp e1))
#                                           (if temp
#                                             temp
#                                             (my-or e2 ...)))))))
#                  (let ((x false)
#                        (y 7)
#                        (temp 8)
#                        (let odd?)
#                        (if even?))
#                    (my-or x
#                           (let temp)
#                           (if y)
#                           y))) 7))
#(assert (equal? (let ((=> false))
#                  (cond (true => 'ok))) ok))
#(assert (equal? (= (symbol->string obj1)
#                          (symbol->string obj2)) true))
#(assert (equal? (= (symbol->string obj1)
#                          (symbol->string obj2)) false))
(assert (equal? (eqv? 'a 'a) true))
(assert (equal? (eqv? 'a 'b) false))
(assert (equal? (eqv? 2 2) true))
(assert (equal? (eqv? '() '()) true))
(assert (equal? (eqv? 100000000 100000000) true))
(assert (equal? (eqv? (cons 1 2) (cons 1 2)) false))
(assert (equal? (eqv? (lambda () 1)
                      (lambda () 2)) false))
(assert (equal? (eqv? false 'nil) false))
(assert (equal? (let ((p (lambda (x) x)))
                  (eqv? p p)) true))
(assert (equal? (eqv? "" "") true)) ; false in scheme
(assert (equal? (eqv? '[] '[]) false))
(assert (equal? (eqv? (lambda (x) x)
                      (lambda (x) x)) false))
(assert (equal? (eqv? (lambda (x) x)
                      (lambda (y) y)) false))
(define gen-counter
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(assert (equal? (let ((g (gen-counter)))
                  (eqv? g g)) true))
(assert (equal? (eqv? (gen-counter) (gen-counter)) false))
(define gen-loser
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) 27))))
(assert (equal? (let ((g (gen-loser)))
                  (eqv? g g)) true))
(assert (equal? (eqv? (gen-loser) (gen-loser)) false))
(assert (equal? (letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
                         (g (lambda () (if (eqv? f g) 'both 'g))))
                  (eqv? f g)) false))
(assert (equal? (letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
                         (g (lambda () (if (eqv? f g) 'g 'both))))
                  (eqv? f g)) false))
(assert (equal? (eqv? '(a) '(a)) false))
(assert (equal? (eqv? "a" "a") true)) ; false in scheme
(assert (equal? (eqv? '(b) (cdr '(a b))) false))
(assert (equal? (let ((x '(a)))
                  (eqv? x x)) true))
(assert (equal? (eq? 'a 'a) true))
(assert (equal? (eq? '(a) '(a)) false))
(assert (equal? (eq? (list 'a) (list 'a)) false))
(assert (equal? (eq? "a" "a") false))
(assert (equal? (eq? "" "") false))
(assert (equal? (eq? '() '()) true))
(assert (equal? (eq? 2 2) false))
(assert (equal? (eq? %\A %\A) false))
(assert (equal? (eq? car car) true))
(assert (equal? (let ((n (+ 2 3)))
                  (eq? n n)) true))
(assert (equal? (let ((x '(a)))
                  (eq? x x)) true))
(assert (equal? (let ((x '[]))
                  (eq? x x)) true))
(assert (equal? (let ((p (lambda (x) x)))
                  (eq? p p)) true))
(assert (equal? (equal? 'a 'a) true))
(assert (equal? (equal? '(a) '(a)) true))
(assert (equal? (equal? '(a (b) c)
                        '(a (b) c)) true))
(assert (equal? (equal? "abc" "abc") true))
(assert (equal? (equal? 2 2) true))
(assert (equal? (equal? (make-vector 5 'a)
                        (make-vector 5 'a)) true))
(assert (equal? (equal? (lambda (x) x)
                        (lambda (y) y)) false))
#(assert (equal? (complex? 3+4i) true))
(assert (complex? 3))
(assert (real? 3))
#(assert (real? -2.5+0.0i))
#(assert (real? %e1e10))
(assert (rational? (/ 6 10))) # TODO: replace with below
#(assert (rational? 6/10))
(assert (rational? (/ 6 3))) # TODO: replace with below
#(assert (rational? 6/3))
#(assert (integer? 3+0i))
(assert (integer? 3.0))
(assert (integer? (/ 8 4))) # TODO: replace with below
#(assert (integer? 8/4))
(assert (equal? (max 3 4) 4)) # exact
(assert (exact? (max 3 4))) # exact
(assert (equal? (max 3.9 4) 4.0)) # inexact
(assert (inexact? (max 3.9 4)))
(assert (equal? (+ 3 4) 7))
(assert (equal? (+ 3) 3))
(assert (equal? (+) 0))
(assert (equal? (* 4) 4))
(assert (equal? (*) 1))
(assert (equal? (- 3 4) -1))
(assert (equal? (- 3 4 5) -6))
(assert (equal? (- 3) -3))
#(assert (equal? (/ 3 4 5) 3/20))
#(assert (equal? (/ 3) 1/3))
(assert (equal? (abs -7) 7))
(define n1 0)
(define n2 1)
#(assert (equal? (quotient n1 n2) n1/n2))
(assert (equal? (remainder n1 n2) 0))
(assert (equal? (modulo n1 n2) 0))
#(assert (equal? (quotient n1 n2) nq))
#(assert (equal? (remainder n1 n2) nr))
#(assert (equal? (modulo n1 n2) nm))
(assert (equal? (= n1 (+ (* n2 (quotient n1 n2))
                         (remainder n1 n2))) true))
(assert (equal? (modulo 13 4) 1))
(assert (equal? (remainder 13 4) 1))
(assert (equal? (modulo -13 4) 3))
(assert (equal? (remainder -13 4) -1))
(assert (equal? (modulo 13 -4) -3))
(assert (equal? (remainder 13 -4) 1))
(assert (equal? (modulo -13 -4) -1))
(assert (equal? (remainder -13 -4) -1))
(assert (equal? (remainder -13 -4.0) -1.0)) # inexact
(assert (equal? (gcd 32 -36) 4))
(assert (equal? (gcd) 0))
(assert (equal? (lcm 32 -36) 288))
(assert (equal? (lcm 32.0 -36) 288.0)) # inexact
(assert (equal? (lcm) 1))
(assert (equal? (numerator (/ 6 4)) 3))
(assert (equal? (denominator (/ 6 4)) 2))
#(assert (equal? (denominator
#                  (inexact (/ 6 4))) 2.0))
(assert (equal? (floor -4.3) -5.0))
(assert (equal? (ceiling -4.3) -4.0))
(assert (equal? (truncate -4.3) -4.0))
(assert (equal? (round -4.3) -4.0))
(assert (equal? (floor 3.5) 3.0))
(assert (equal? (ceiling 3.5) 4.0))
(assert (equal? (truncate 3.5) 3.0))
(assert (equal? (round 3.5) 4.0)) # inexact
(assert (equal? (round 7/2) 4)) # exact
(assert (equal? (round 7) 7))
#(assert (equal? (rationalize
#                  (exact .3) 1/10) 1/3)) # exact
#(assert (equal? (rationalize .3 1/10) %i1/3)) # inexact
(assert (= (square 42) 1764))
(assert (= (square 2.0) 4.0))
#(assert (equal? (make-rectangular x1 x2) z))
#(assert (equal? (make-polar x3 x4) z))
#(assert (equal? (real-part z) x1))
#(assert (equal? (imag-part z) x2))
#(assert (equal? (magnitude z) |x3|))
#(assert (equal? (angle z) xangle))
(assert (equal? (string->number "100") 100))
#(assert (equal? (string->number "100" 16) 256))
(assert (equal? (string->number "1e2") 100.0))
#(assert (equal? (string->number "15##") 1500.0))
(assert (equal? true true))
(assert (equal? false false))
(assert (equal? 'false false))
(assert (equal? (not true) false))
(assert (equal? (not 3) false))
(assert (equal? (not (list 3)) false))
(assert (equal? (not false) true))
(assert (equal? (not '()) false))
(assert (equal? (not (list)) false))
(assert (equal? (not 'nil) false))
(assert (equal? (boolean? false) true))
(assert (equal? (boolean? 0) false))
(assert (equal? (boolean? '()) false))
(define x (list 'a 'b 'c))
(define y x)
(assert (equal? y '(a b c)))
(assert (equal? (list? y) true))
(assert (equal? (set-cdr! x 4) null))
(assert (equal? x '(a . 4)))
(assert (equal? (eqv? x y) true))
(assert (equal? y '(a . 4)))
(assert (equal? (list? y) false))
#(assert (equal? (set-cdr! x x) null)) # TODO: fix inf loop
(assert (equal? (list? x) false))
(assert (equal? (pair? '(a . b)) true))
(assert (equal? (pair? '(a b c)) true))
(assert (equal? (pair? '()) false))
(assert (equal? (pair? '[a b]) false))
(assert (equal? (cons 'a '()) '(a)))
(assert (equal? (cons '(a) '(b c d)) '((a) b c d)))
(assert (equal? (cons "a" '(b c)) '("a" b c)))
(assert (equal? (cons 'a 3) '(a . 3)))
(assert (equal? (cons '(a b) 'c) '((a b) . c)))
(assert (equal? (car '(a b c)) 'a))
(assert (equal? (car '((a) b c d)) '(a)))
(assert (equal? (car '(1 . 2)) 1))
#(assert (equal? (car '()) error))
(assert (equal? (cdr '((a) b c d)) '(b c d)))
(assert (equal? (cdr '(1 . 2)) 2))
#(assert (equal? (cdr '()) error))
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(assert (equal? (set-car! (f) 3) null))
#(assert (equal? (set-car! (g) 3) error))
(assert (equal? (list? '(a b c)) true))
(assert (equal? (list? '()) true))
(assert (equal? (list? '(a . b)) false))
#(assert (equal? (let ((x (list 'a)))
#                  (set-cdr! x x)
#                  (list? x)) false))
(assert (equal? (list 'a (+ 3 4) 'c) '(a 7 c)))
(assert (equal? (list) ()))
(assert (equal? (length '(a b c)) 3))
(assert (equal? (length '(a (b) (c d e))) 3))
(assert (equal? (length '()) 0))
(assert (equal? (append '(x) '(y)) '(x y)))
(assert (equal? (append '(a) '(b c d)) '(a b c d)))
(assert (equal? (append '(a (b)) '((c))) '(a (b) (c))))
(assert (equal? (append '(a b) '(c . d)) '(a b c . d)))
(assert (equal? (append '() 'a) 'a))
(assert (equal? (reverse '(a b c)) '(c b a)))
(assert (equal? (reverse '(a (b c) d (e (f)))) '((e (f)) d (b c) a)))
(assert (equal? (ref '(a b c d) 2) 'c))
#(assert (equal? (ref '(a b c d)
#                          (exact (round 1.8))) 'c))
(assert (equal? (memq 'a '(a b c)) '(a b c)))
(assert (equal? (memq 'b '(a b c)) '(b c)))
(assert (equal? (memq 'a '(b c d)) false))
(assert (equal? (memq (list 'a) '(b (a) c)) false))
(assert (equal? (member (list 'a)
                        '(b (a) c)) '((a) c)))
(assert (equal? (memq 101 '(100 101 102)) false))
(assert (equal? (memv 101 '(100 101 102)) '(101 102)))
(define e '((a 1) (b 2) (c 3)))
(assert (equal? 
          (assq 'a e) '(a 1)))
(assert (equal? (assq 'b e) '(b 2)))
(assert (equal? (assq 'd e) false))
(assert (equal? (assq (list 'a) '(((a)) ((b)) ((c)))) false))
(assert (equal? (assoc (list 'a) '(((a)) ((b)) ((c)))) '((a))))
(assert (equal? (assq 5 '((2 3) (5 7) (11 13))) false))
(assert (equal? (assv 5 '((2 3) (5 7) (11 13))) '(5 7)))
(assert (equal? (symbol? 'foo) true))
(assert (equal? (symbol? (car '(a b))) true))
(assert (equal? (symbol? "bar") false))
(assert (equal? (symbol? 'nil) true))
(assert (equal? (symbol? '()) false))
#(assert (equal? (symbol? false) false))
(assert (equal? (symbol->string 'flying-fish) "flying-fish"))
(assert (not (equal? (symbol->string 'Martin) "martin")))
(assert (equal? (symbol->string
                  (string->symbol "Malvina")) "Malvina"))
(assert (equal? (eq? 'mISSISSIppi 'mississippi) false))
(assert (equal? (string->symbol "mISSISSIppi") 'mISSISSIppi))
(assert (equal? (eq? 'bitBlt (string->symbol "bitBlt")) true))
(assert (equal? (eq? 'JollyWog
                     (string->symbol
                       (symbol->string 'JollyWog))) true))
(assert (equal? (= "K. Harper, M.D."
                   (symbol->string
                     (string->symbol "K. Harper, M.D."))) true))
#(assert (equal? (char<=? a b) true))
#(assert (equal? (<= x y) true))
#(assert (equal? (<= (char->integer a)
#                    (char->integer b)) true))
#(assert (equal? (char<=? (integer->char x)
#                         (integer->char y)) true))
#(define (f) (make-string 3 %\*)) # TODO: fix make-string
#(define (g) "***")
#(assert (equal?
#          (string-set! (f) 0 %\?) unspecified))
#(assert (equal? (string-set! (g) 0 %\?) error))
#(assert (equal? (string-set! (symbol->string 'immutable)
#                             0
#                             %\?) error))
(assert (equal? '[0 (2 2 2 2) "Anna"] [0 (2 2 2 2) "Anna"]))
(assert (equal? (vector 'a 'b 'c) [a b c]))
(assert (equal? (ref '[1 1 2 3 5 8 13 21]
                            5) 8))
#(assert (equal? (ref '[1 1 2 3 5 8 13 21]
#                            (let ((i (round (* 2 (acos -1)))))
#                              (if (inexact? i)
#                                (exact i)
#                                i))) 13))
(assert (equal? (let ((vec (vector 0 '(2 2 2 2) "Anna")))
                  (set vec 1 '("Sue" "Sue"))
                  vec) [0 ("Sue" "Sue") "Anna"]))
#(assert (equal? (set '[0 1 2] 1 "doe") error)) # constant vector
(assert (equal? (vector->list '[dah dah didah]) '(dah dah didah)))
(assert (equal? (list->vector '(dididit dah)) [dididit dah]))
(assert (equal? (procedure? car) true))
(assert (equal? (procedure? 'car) false))
(assert (equal? (procedure? (lambda (x) (* x x))) true))
(assert (equal? (procedure? '(lambda (x) (* x x))) false))
#(assert (equal? (call-with-current-continuation procedure?) true))
(assert (equal? (apply + (list 3 4)) 7))
(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))
(assert (equal? ((compose sqrt *) 12 75) 30))
(assert (equal? (map cadr '((a b) (d e) (g h))) '(b e h)))
(assert (equal? (map (lambda (n) (expt n n))
                     '(1 2 3 4 5)) '(1 4 27 256 3125)))
(assert (equal? (map + '(1 2 3) '(4 5 6)) '(5 7 9)))
(assert (equal? (let ((count 0))
                  (map (lambda (ignored)
                         (set! count (+ count 1))
                         count)
                       '(a b))) '(1 2)))
(assert (equal? (let ((v (make-vector 5)))
                  (for-each (lambda (i)
                              (set v i (* i i)))
                            '(0 1 2 3 4))
                  v) [0 1 4 9 16]))
(assert (equal? (force (delay (+ 1 2))) 3))
(assert (equal? (let ((p (delay (+ 1 2))))
                  (list (force p) (force p))) '(3 3)))
(define a-stream
  (letrec ((next
             (lambda (n)
               (cons n (delay (next (+ n 1)))))))
    (next 0)))
(define head car)
(define tail
  (lambda (stream) (force (cdr stream))))
(assert (equal? (head (tail (tail a-stream))) 2))
(define count 0)
(define p
  (delay (begin (set! count (+ count 1))
                (if (> count x)
                  count
                  (force p)))))
(define x 5)
#(assert (equal? p a promise))
(assert (equal? (force p) 6))
#(assert (equal? p a promise, still))
#(assert (equal? (begin (set! x 10)
#                       (force p)) 6))
(assert (equal? (eqv? (delay 1) 1) false))
(assert (equal? (pair? (delay (cons 1 2))) false))
#(assert (equal? (+ (delay (* 3 7)) 13) 34))
#(assert (equal? (+ (delay (* 3 7)) 13) 34))
#(assert (equal? (+ (delay (* 3 7)) 13) 34))
#(assert (equal? (call-with-current-continuation
#                  (lambda (exit)
#                    (for-each (lambda (x)
#                                (if (negative? x)
#                                  (exit x)))
#                              '(54 0 37 -3 245 19))
#                    true)) -3))
#(define list-length
#  (lambda (obj)
#    (call-with-current-continuation
#      (lambda (return)
#        (letrec ((r
#                   (lambda (obj)
#                     (cond ((null? obj) 0)
#                           ((pair? obj)
#                            (+ (r (cdr obj)) 1))
#                           (else (return false))))))
#          (r obj))))))
#(assert (equal? (list-length '(1 2 3 4)) 4))
#(assert (equal? (list-length '(a b . c)) false))
#(assert (equal? (call-with-values (lambda () (values 4 5))
#                                  (lambda (a b) b)) 5))
#(assert (equal? (call-with-values * -) -1))
#(assert (equal? (let ((path '())
#                      (c false))
#                  (let ((add (lambda (s)
#                               (set! path (cons s path)))))
#                    (dynamic-wind
#                      (lambda () (add 'connect))
#                      (lambda ()
#                        (add (call-with-current-continuation
#                               (lambda (c0)
#                                 (set! c c0)
#                                 'talk1))))
#                      (lambda () (add 'disconnect)))
#                    (if (< (length path) 4)
#                      (c 'talk2)
#                      (reverse path)))) (connect talk1 disconnect connect talk2 disconnect)))
#(assert (equal? (eval '(* 7 3) (scheme-report-environment 5)) 21))
#(assert (equal? (let ((f (eval '(lambda (f x) (f x x))
#                               (null-environment 5))))
#                  (f + 10)) 20))

(import test-stack)
(import test-bind)
(import test-sort)
(import test-match)
(import test-syntax)
(import test-string)
(import test-sock)
(print "all tests passed!")
(print (timer) "seconds")
