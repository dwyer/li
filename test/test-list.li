(let ()
  (import (scheme cxr))
  (import (li defmacro))
  (import (li list))

  (defmacro (test . clauses)
    `(begin
       ,@(map (lambda (clause)
                (let ((expr (car clause))
                      (res (caddr clause)))
                  `(assert (equal? ,expr ',res))))
              clauses)))

  (define (identity x) x)
  (define e '((a 1) (b 2) (c 3)))

  (test ((xcons '(b c) 'a) => (a b c))
        ((cons* 1 2 3 4) => (1 2 3 . 4))
        ((cons* 1) => 1)
        ((make-list 4 'c) => (c c c c))
        ((list-tabulate 4 values) => (0 1 2 3))
        ((list-copy '(1 2 3)) => (1 2 3))
        ((take (circular-list 'z 'q) 6) => (z q z q z q))
        ((iota 5) => (0 1 2 3 4))
        ((iota 5 0 -0.1) => (0 -0.1 -0.2 -0.3 -0.4))
        ((proper-list? '(1 2 3)) => #t)
        ((proper-list? (circular-list 1 2 3)) => #f)
        ((proper-list? '(1 2 . 3)) => #f)
        ((circular-list? '(1 2 3)) => #f)
        ((circular-list? (circular-list 1 2 3)) => #t)
        ((circular-list? '(1 2 . 3)) => #f)
        ((dotted-list? '(1 2 3)) => #f)
        ((dotted-list? (circular-list 1 2 3)) => #f)
        ((dotted-list? '(1 2 . 3)) => #t)
        ((list= eq?) => #t)
        ((list= eq? '(a)) => #t)
        ((list= eq? '(a) '(a)) => #t)
        ((list= eq? '(a) '(b)) => #f)

        ((ref '(a b c d) 2) => c)
        ((third '(a b c d e)) => c)
        ((take '(a b c d e) 2) => (a b))
        ((drop '(a b c d e) 2) => (c d e))
        ((take '(1 2 3 . d) 2) => (1 2))
        ((drop '(1 2 3 . d) 2) => (3 . d))
        ((take '(1 2 3 . d) 3) => (1 2 3))
        ((drop '(1 2 3 . d) 3) => d)
        ((take-right '(a b c d e) 2) => (d e))
        ((drop-right '(a b c d e) 2) => (a b c))
        ((take-right '(1 2 3 . d) 2) => (2 3 . d))
        ((drop-right '(1 2 3 . d) 2) => (1))
        ((take-right '(1 2 3 . d) 0) => d)
        ((drop-right '(1 2 3 . d) 0) => (1 2 3))
        ((take! '(a b c d e) 2) => (a b))
        ((take! '(1 2 3 . d) 2) => (1 2))
        ((take! '(1 2 3 . d) 3) => (1 2 3))
        ((take! (circular-list 1 3 5) 8) => (1 3))
        ((split-at '(a b c d e f g h) 3) => [values (a b c) (d e f g h)])
        ((last '(a b c)) => c)
        ((last-pair '(a b c)) => (c))

        ((append '(x) '(y))        =>  (x y))
        ((append '(a) '(b c d))    =>  (a b c d))
        ((append '(a (b)) '((c)))  =>  (a (b) (c)))
        ((append '(a b) '(c . d))  =>  (a b c . d))
        ((append '() 'a)           =>  a)
        ((append '(x y))           =>  (x y))
        ((append)                  =>  ())
        ((reverse '(a b c)) =>  (c b a))
        ((reverse '(a (b c) d (e (f)))) => ((e (f)) d (b c) a))
        ((append-reverse '(1 2 3 4) 5) => (4 3 2 1 . 5))

        ((zip '(one two three) '(1 2 3) '(odd even odd even odd even odd even))
         => ((one 1 odd) (two 2 even) (three 3 odd)))
        ((zip '(1 2 3)) => ((1) (2) (3)))
        ((zip '(3 1 4 1) (circular-list #f #t))
         => ((3 #f) (1 #t) (4 #f) (1 #t)))
        ((unzip2 '((1 one) (2 two) (3 three))) => [values (1 2 3) (one two three)])
        ((count even? '(3 1 4 1 5 9 2 5 6)) => 3)
        ((count < '(1 2 4 8) '(2 4 6 8 10 12 14 16)) => 3)
        ((count < '(3 1 4 1) (circular-list 1 10)) => 2)
        ((fold + 0 '(1 2 3 4)) => 10)
        ((fold (lambda (x count) (if (symbol? x) (+ count 1) count)) 0
               '(a b 1 2 c d 3 4 e))
         => 5)
        ((fold (lambda (s max-len) (max max-len (length s))) 0
               '("the" "quick" "brown" "fox" "jumps" "over" "the" "lazy" "dog"))
         => 5)
        ((fold cons* null '(a b c) '(1 2 3 4 5)) => (c 3 b 2 a 1))
        ((fold-right cons '() '(1 2 3 4)) => (1 2 3 4))
        ((fold-right (lambda (x l) (if (even? x) (cons x l) l)) '()
                     '(1 2 3 4 5 6))
         => (2 4 6))
        ((fold-right cons* '() '(a b c) '(1 2 3 4 5)) => (a 1 b 2 c 3))
        ((pair-fold (lambda (pair tail) (set-cdr! pair tail) pair) '() '(1 2 3 4))
         => (4 3 2 1))
        ((pair-fold-right cons '() '(a b c)) => ((a b c) (b c) (c)))
        ((unfold (lambda (x) (> x 10)) (lambda (x) (* x x)) (lambda (x) (+ x 1)) 1)
         => (1 4 9 16 25 36 49 64 81 100))
        ((unfold null-list? car cdr '(1 2 3 4)) => (1 2 3 4))
        ((map cadr '((a b) (d e) (g h))) => (b e h))
        ((map (lambda (n) (expt n n)) '(1 2 3 4 5)) => (1 4 27 256 3125))
        ((map + '(1 2 3) '(4 5 6)) => (5 7 9))
        ((let ((count 0))
           (map (lambda (ignored)
                  (set! count (+ count 1))
                  count)
                '(a b)))
         => (1 2))
        ((map + '(3 1 4 1) (circular-list 1 0)) => (4 1 5 1))
        ((filter-map (lambda (x) (and (number? x) (* x x))) '(a 1 b 3 c 7)) => (1 9 49))
        ((filter-map cadr '((a b) (d e) (g h))) => (b e h))
        ((filter-map (lambda (n) (expt n n)) '(1 2 3 4 5)) => (1 4 27 256 3125))
        ((filter-map + '(1 2 3) '(4 5 6)) => (5 7 9))
        ((filter even? '(0 7 8 8 43 -4)) => (0 8 8 -4))
        ((partition symbol? '(one 2 3 four five 6)) => [values (one four five) (2 3 6)])
        ((remove even? '(0 7 8 8 43 -4)) => (7 43))
        ((find even? '(3 1 4 1 5 9)) => 4)
        ((find-tail even? '(3 1 37 -8 -5 0 0)) => (-8 -5 0 0))
        ((find-tail even? '(3 1 37 -5)) => #f)
        ((take-while even? '(2 18 3 10 22 9)) => (2 18))
        ((drop-while even? '(2 18 3 10 22 9)) => (3 10 22 9))
        ((span even? '(2 18 3 10 22 9)) => [values (2 18) (3 10 22 9)])
        ((break even? '(3 1 4 1 5 9)) => [values (3 1) (4 1 5 9)])
        ((any integer? '(a 3 b 2.7)) => #t)
        ((any integer? '(a 3.1 b 2.7)) => #f)
        ((any < '(3 1 4 1 5) '(2 7 1 8 2)) => #t)
        ((list-index even? '(3 1 4 1 5 9)) => 2)
        ((list-index < '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)) => 1)
        ((list-index = '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)) => #f)

        ((delete-duplicates '(a b a c a b c z)) => (a b c z))
        ((delete-duplicates '((a . 3) (b . 7) (a . 9) (c . 1))
                            (lambda (x y) (eq? (car x) (car y))))
         => ((a . 3) (b . 7) (c . 1)))
        ((assq 'a e)                            =>  (a 1))
        ((assq 'b e)                            =>  (b 2))
        ((assq 'd e)                            =>  #f)
        ((assq (list 'a) '(((a)) ((b)) ((c))))  =>  #f)
        ((assoc (list 'a) '(((a)) ((b)) ((c)))) =>  ((a)))
        ((assq 5 '((2 3) (5 7) (11 13)))	   =>  #f)
        ((assv 5 '((2 3) (5 7) (11 13)))	   =>  (5 7))
        ((alist-delete 5 '((2 3) (5 7) (11 13))) => ((2 3) (11 13)))
        ((alist-delete 5 '((2 3) (5 7) (11 13)) <) => ((2 3) (5 7)))
        ))
