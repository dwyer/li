(import list)

(defmacro (test . clauses)
  `(begin
     ,@(map (lambda (clause)
              (let ((expr (car clause))
                    (res (caddr clause)))
                `(assert (equal? ,expr ',res))))
            clauses)))

(define (identity x) x)
(define values identity)

(display 'testing-list...)
(test ((xcons '(b c) 'a) => (a b c))
      ((cons* 1 2 3 4) => (1 2 3 . 4))
      ((cons* 1) => 1)
      ((make-list 4 'c) => (c c c c))
      ((list-tabulate 4 values) => (0 1 2 3))
      ;((list= eq?) => true)
      ;((list= eq? '(a)) => true)
      ((list-ref '(a b c d) 2) => c)
      ((third '(a b c d e)) => c)
      ((take '(a b c d e)  2) => (a b))
      ((drop '(a b c d e)  2) => (c d e))
      ((take '(1 2 3 . d) 2) => (1 2))
      ((drop '(1 2 3 . d) 2) => (3 . d))
      ((take '(1 2 3 . d) 3) => (1 2 3))
      ((drop '(1 2 3 . d) 3) => d)
      ((take-right '(a b c d e) 2) => (d e))
      ((drop-right '(a b c d e) 2) => (a b c))
      #((take-right '(1 2 3 . d) 2) => (2 3 . d))
      #((drop-right '(1 2 3 . d) 2) => (1))
      #((take-right '(1 2 3 . d) 0) => d)
      #((drop-right '(1 2 3 . d) 0) => (1 2 3))
      ((take! (circular-list 1 3 5) 8) => (1 3))
      ((last '(a b c)) => c)
      ((last-pair '(a b c)) => (c))
      ((append '(x) '(y))        =>  (x y))
      ((append '(a) '(b c d))    =>  (a b c d))
      ((append '(a (b)) '((c)))  =>  (a (b) (c)))
      ((append '(a b) '(c . d))  =>  (a b c . d))
      ((append '() 'a)           =>  a)
      ((append '(x y))           =>  (x y))
      ((append)                  =>  ())
      )
(print 'done)
