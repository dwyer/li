(load "test/lib.sub")

# 11.2.1  Variable defineinitions
(define add3
  (lambda (x) (+ x 3)))
(assert (equal? (add3 3) 6))
(define first car)
(assert (equal? (first `(1 2)) 1))

# 11.3  Bodies
(assert (equal? (let ((x 5))
                  (define foo (lambda (y) (bar x y)))
                  (define bar (lambda (a b) (+ (* a b) a)))
                  (foo (+ x 3))) 45))

# 11.4.1  Quotation
(assert (equal? (quasiquote a) `a))
(assert (equal? (quasiquote %(a b c)) %(a b c)))
(assert (equal? (quasiquote (+ 1 2)) `(+ 1 2)))
(assert (equal? `"abc" "abc"))
(assert (equal? `145932 145932))
(assert (equal? `a (quasiquote a)))
(assert (equal? null (quasiquote ())))
(assert (equal? `(+ 1 2) (quasiquote (+ 1 2))))
(assert (equal? `(quasiquote a) (quasiquote (quasiquote a))))
(assert (equal? ``a (quasiquote (quasiquote a))))

# 11.4.2  Procedures
(lambda (x) (+ x x))
(assert (equal? ((lambda (x) (+ x x)) 4) 8))
(assert (equal? ((lambda (x)
                   (define (p y)
                     (+ y 1))
                   (+ (p x) x))
                 5) 11))
(define reverse-subtract
  (lambda (x y) (- y x)))
(assert (equal? (reverse-subtract 7 10) 3))
(define add4
  (let ((x 4))
    (lambda (y) (+ x y))))

(assert (equal? (add4 6) 10))
(assert (equal? ((lambda x x) 3 4 5 6) `(3 4 5 6)))
(assert (equal? ((lambda (x y . z) z)
                 3 4 5 6) `(5 6)))

# 11.4.3  Conditionals
(assert (equal? (if (> 3 2) `yes `no) `yes))
(assert (equal? (if (> 2 3) `yes `no) `no))
(assert (equal? (if (> 3 2)
                  (- 3 2)
                  (+ 3 2)) 1))
(assert (equal? (if false false) false)) # unspecified

# 11.4.4  Assignments
(assert (equal? (let ((x 2))
                  (+ x 1)
                  (set! x 4)
                  (+ x 1)) 5))

# 11.4.5  Derived conditionals
(assert (equal? (cond ((> 3 2) `greater)
                      ((< 3 2) `less)) `greater))
(assert (equal? (cond ((> 3 3) `greater)
                      ((< 3 3) `less)
                      (else `equal)) `equal))
# (assert (equal? (cond (`(1 2 3) => cadr)
#       (else false)) 2)) # not supported
(assert (equal?
          (case (* 2 3)
            ((2 3 5 7) `prime)
            ((1 4 6 8 9) `composite))
          `composite))
(assert (equal? (case (car `(c d))
                  ((a) `a)
                  ((b) `b)) false))
(assert (equal? (case (car `(c d))
                  ((a e i o u) `vowel)
                  ((w y) `semivowel)
                  (else `consonant)) `consonant))
(assert (equal? (and (= 2 2) (< 2 1)) false))
(assert (equal? (and 1 2 `c `(f g)) `(f g)))
(assert (equal? (and) true))
(assert (equal? (or (= 2 2) (> 2 1)) true))
(assert (equal? (or (= 2 2) (< 2 1)) true))
(assert (equal? (or false false false) false))
(assert (equal? (or `(b c) (/ 3 0)) `(b c)))

# 11.4.6  Binding constructs
(assert (equal? (let ((x 2) (y 3))
                  (* x y)) 6))
(assert (equal? (let ((x 2) (y 3))
                  (let ((x 7)
                        (z (+ x y)))
                    (* z x))) 35))
(assert (equal? (let ((x 2) (y 3))
                  (let* ((x 7)
                         (z (+ x y)))
                    (* z x))) 70))

# 11.4.7  Sequencing
(define x 0)
(assert (equal? (begin (set! x 5)
                       (+ x 1)) 6))
#(assert (equal? (begin (display "4 plus 1 equals ")
#                       (display (+ 4 1))) null)) # unspecified

# 11.5  Equivalence predicates
(assert (equal? (eqv? `a `a) true))
(assert (equal? (eqv? `a `b) false))
(assert (equal? (eqv? 2 2) true))
(assert (equal? (eqv? null null) true))
(assert (equal? (eqv? 100000000 100000000) true))
(assert (equal? (eqv? (cons 1 2) (cons 1 2)) false))
(assert (equal? (eqv? (lambda () 1)
                      (lambda () 2)) false))
(assert (equal? (eqv? false `null) false))
(assert (equal? (let ((p (lambda (x) x)))
                  (eqv? p p)) true))
(assert (equal? (eqv? "" "") false))
(assert (equal? (eqv? %() %()) false))
(assert (equal? (eqv? (lambda (x) x)
                      (lambda (x) x)) false))
(assert (equal? (eqv? (lambda (x) x)
                      (lambda (y) y)) false))
(define gen-counter
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(assert (equal? (let ((g (gen-counter)))
                  (eqv? g g)) true))
(assert (equal? (eqv? (gen-counter) (gen-counter)) false))
(define gen-loser
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) 27))))
(assert (equal? (let ((g (gen-loser)))
                  (eqv? g g)) true))
(assert (equal? (eqv? (gen-loser) (gen-loser)) false))
(assert (equal? (eqv? `(a) `(a)) false))
(assert (equal? (eqv? "a" "a") false))
(assert (equal? (eqv? `(b) (cdr `(a b))) false))
(assert (equal? (let ((x `(a)))
                  (eqv? x x)) true))
(assert (equal? (eq? `a `a) true))
(assert (equal? (eq? `(a) `(a)) false))
(assert (equal? (eq? (list `a) (list `a)) false))
(assert (equal? (eq? "a" "a") false))
(assert (equal? (eq? "" "") false))
(assert (equal? (eq? null null) true))
(assert (equal? (eq? 2 2) false))
(assert (equal? (eq? car car) true))
(assert (equal? (let ((n (+ 2 3)))
                  (eq? n n)) true))
(assert (equal? (let ((x `(a)))
                  (eq? x x)) true))
(assert (equal? (let ((x %()))
                  (eq? x x)) true))
(assert (equal? (let ((p (lambda (x) x)))
                  (eq? p p)) true))
(assert (equal? (equal? `a `a) true))
(assert (equal? (equal? `(a) `(a)) true))
(assert (equal? (equal? `(a (b) c)
                        `(a (b) c)) true))
(assert (equal? (equal? "abc" "abc") true))
(assert (equal? (equal? 2 2) true))
(assert (equal? (equal? (make-vector 5 `a)
                        (make-vector 5 `a)) true))
(assert (equal? (equal? (lambda (x) x)
                        (lambda (y) y)) false))

# 11.6  Procedure predicate
(assert (equal? (procedure? car) true))
(assert (equal? (procedure? `car) false))
(assert (equal? (procedure? (lambda (x) (* x x))) true))
(assert (equal? (procedure? `(lambda (x) (* x x))) false))

# 11.7  Arithmetic

# 11.7.4.3  Arithmetic operations
(assert (equal? (max 3 4) 4))
(assert (equal? (max 3.9 4) 4.0))
(assert (equal? (+ 3 4) 7))
(assert (equal? (+ 3) 3))
(assert (equal? (+) 0))
(assert (equal? (* 4) 4))
(assert (equal? (*) 1))
(assert (equal? (* 1.0 0) 0))
(assert (equal? (- 3 4) -1))
(assert (equal? (- 3 4 5) -6))
(assert (equal? (- 3) -3))
(assert (equal? (/ 3 4 5) (/ 3 20)))
(assert (equal? (/ 3) (/ 1 3)))
(assert (equal? (/ 0 3.5) 0.0))
(assert (equal? (abs -7) 7))
(assert (equal? (gcd 32 -36) 4))
(assert (equal? (gcd) 0))
(assert (equal? (lcm 32 -36) 288))
(assert (equal? (lcm 32.0 -36) 288.0))
(assert (equal? (lcm) 1))
(assert (equal? (expt 5 3) 125))
# This one passes under normal circumstances but fails in Valgrind.
# (assert (equal? (expt 5 -3) (/ 1 125)))
(assert (equal? (expt 5 0) 1))
(assert (equal? (expt 0 5) 0))
(assert (equal? (expt 0 0) 1))
(assert (equal? (expt 0.0 0.0) 1.0))
# 11.8  Booleans
(assert (equal? (not true) false))
(assert (equal? (not 3) false))
(assert (equal? (not (list 3)) false))
(assert (equal? (not false) true))
(assert (equal? (not null) false))
(assert (equal? (not (list)) false))
(assert (equal? (not `null) false))
(assert (equal? (boolean? false) true))
(assert (equal? (boolean? 0) false))
(assert (equal? (boolean? null) false))
# 11.9  Pairs and lists
# ERROR: (assert (equal? (a b c . d) `(a . (b . (c . d)))))
(assert (equal? (pair? `(a . b)) true))
(assert (equal? (pair? `(a b c)) true))
(assert (equal? (pair? null) false))
(assert (equal? (pair? %(a b)) false))
(assert (equal? (cons `a null) `(a)))
(assert (equal? (cons `(a) `(b c d)) `((a) b c d)))
(assert (equal? (cons "a" `(b c)) `("a" b c)))
(assert (equal? (cons `a 3) `(a . 3)))
(assert (equal? (cons `(a b) `c) `((a b) . c)))
(assert (equal? (car `(a b c)) `a))
(assert (equal? (car `((a) b c d)) `(a)))
(assert (equal? (car `(1 . 2)) `1))
(assert (equal? (cdr `((a) b c d)) `(b c d)))
(assert (equal? (cdr `(1 . 2)) `2))
(assert (equal? (list? `(a b c)) true))
(assert (equal? (list? null) true))
(assert (equal? (list? `(a . b)) false))
(assert (equal? (list `a (+ 3 4) `c) `(a 7 c)))
(assert (equal? (list) null))
(assert (equal? (length `(a b c)) `3))
(assert (equal? (length `(a (b) (c d e))) `3))
(assert (equal? (length null) `0))
(assert (equal? (append `(x) `(y)) `(x y)))
(assert (equal? (append `(a) `(b c d)) `(a b c d)))
(assert (equal? (append `(a (b)) `((c))) `(a (b) (c))))
(assert (equal? (append `(a b) `(c . d)) `(a b c . d)))
(assert (equal? (append null `a) `a))
(assert (equal? (reverse `(a b c)) `(c b a)))
(assert (equal? (reverse `(a (b c) d (e (f)))) `((e (f)) d (b c) a)))
(assert (equal? (list-tail `(a b c d) 2) `(c d)))
(assert (equal? (list-ref `(a b c d) 2) `c))
(assert (equal? (memq `a `(a b c)) `(a b c)))
(assert (equal? (memq `b `(a b c)) `(b c)))
(assert (equal? (memq `a `(b c d)) false))
(assert (equal? (memq (list `a) `(b (a) c)) false))
(assert (equal? (member (list `a)
                        `(b (a) c)) `((a) c)))
(assert (equal? (memq 101 `(100 101 102)) false)) # unspecified
(assert (equal? (memv 101 `(100 101 102)) `(101 102)))
(define e `((a 1) (b 2) (c 3)))
(assert (equal? (assq `a e) `(a 1)))
(assert (equal? (assq `b e) `(b 2)))
(assert (equal? (assq `d e) false))
(assert (equal? (assq (list `a) `(((a)) ((b)) ((c)))) false))
(assert (equal? (assoc (list `a) `(((a)) ((b)) ((c)))) `((a))))
(assert (equal? (assq 5 `((2 3) (5 7) (11 13))) false)) # unspecified
(assert (equal? (assv 5 `((2 3) (5 7) (11 13))) `(5 7)))
(assert (equal? (map cadr `((a b) (d e) (g h))) `(b e h)))
(assert (equal? (map (lambda (n) (expt n n))
                     `(1 2 3 4 5)) `(1 4 27 256 3125)))
(assert (equal? (map + `(1 2 3) `(4 5 6)) `(5 7 9)))
(assert (equal? (let ((count 0))
                  (map (lambda (ignored)
                         (set! count (+ count 1))
                         count)
                       `(a b))) `(1 2)))
(assert (equal? (let ((v (make-vector 5)))
                  (for-each (lambda (i)
                              (vector-set! v i (* i i)))
                            `(0 1 2 3 4))
                  v) %(0 1 4 9 16)))
(assert (equal? (for-each (lambda (x) x) `(1 2 3 4)) null))
(assert (equal? (for-each even? null) null))

# 11.10  Symbols
(assert (equal? (symbol? `foo) true))
(assert (equal? (symbol? (car `(a b))) true))
(assert (equal? (symbol? "bar") false))
(assert (equal? (symbol? `null) true))
(assert (equal? (symbol? null) false))
# BUG: (assert (equal? (symbol? false) false))
(assert (equal? (symbol->string `flying-fish) "flying-fish"))
(assert (equal? (symbol->string `Martin) "Martin"))
(assert (equal? (symbol->string
                  (string->symbol "Malvina")) "Malvina"))
(assert (equal? (eq? `mISSISSIppi `mississippi) false))

# 11.11  Characters
# 11.12  Strings
# 11.13  Vectors
(assert (equal? %(0 (2 2 2 2) "Anna") %(0 (2 2 2 2) "Anna")))
(assert (equal? (vector `a `b `c) %(a b c)))
(assert (equal? (vector-ref %(1 1 2 3 5 8 13 21) 5) 8))
(assert (equal? (let ((vec (vector 0 `(2 2 2 2) "Anna")))
                  (vector-set! vec 1 `("Sue" "Sue"))
                  vec) %(0 ("Sue" "Sue") "Anna")))
(assert (equal? (vector-set! %(0 1 2) 1 "doe") "doe"))
(assert (equal? (vector->list %(dah dah didah)) `(dah dah didah)))
(assert (equal? (list->vector `(dididit dah)) %(dididit dah)))
# 11.15  Control features
(assert (equal? (apply + (list 3 4)) 7))
(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))
(assert (equal? ((compose sqrt *) 12 75) 30))

(define (loop numbers nonneg neg)
  (cond ((null? numbers) (list nonneg neg))
        ((>= (car numbers) 0)
         (loop (cdr numbers)
               (cons (car numbers) nonneg)
               neg))
        ((< (car numbers) 0)
         (loop (cdr numbers)
               nonneg
               (cons (car numbers) neg)))))

# 11.16  Iteration
(assert (equal? (let loop ((numbers `(3 -2 1 6 -5))
                           (nonneg null)
                           (neg null))
                  (cond ((null? numbers) (list nonneg neg))
                        ((>= (car numbers) 0)
                         (loop (cdr numbers)
                               (cons (car numbers) nonneg)
                               neg))
                        ((< (car numbers) 0)
                         (loop (cdr numbers)
                               nonneg
                               (cons (car numbers) neg)))))
                `((6 1 3) (-5 -2))))

# force and delay
(assert (equal? (force (delay (+ 1 2))) 3))
(assert (equal? (let ((p (delay (+ 1 2))))
                  (list (force p) (force p))) `(3 3)))
#(define a-stream
#  (letrec ((next
#           (lambda (n)
#             (cons n (delay (next (+ n 1)))))))
#    (next 0)))
(define head car)
(define tail
(lambda (stream) (force (cdr stream))))
#(assert (equal? (head (tail (tail a-stream))) 2))
(define count 0)
(define p
  (delay (begin (set! count (+ count 1))
                (if (> count x)
                  count
                  (force p)))))
(define x 5)
(assert (equal? (force p) 6))
#(assert (equal? (begin (set! x 10)
#                       (force p))
#                6))

(display "all tests passed!")
(newline)
