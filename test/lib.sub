(define (check condition who msg . args)
  (if (not condition)
    (apply error (cons who (cons msg args)))))

(define (cons* . xs)
  (cond ((null? xs) null)
        ((null? (cdr xs)) (car xs))
        (else (cons (car xs) (apply cons* (cdr xs))))))

(define (randint start end)
  (+ start (modulo (rand) (- end start -1))))

(define (range start end)
  (let iter ((k start))
    (if (< k end)
      (cons k (iter (+ k 1)))
      null)))

(define (lcm . args)
  (define (algorithm a b)
    (/ (abs (* a b)) (gcd a b)))
  (cond ((null? args) 1)
        ((null? (cdr args)) (abs (car args)))
        (else
          (apply lcm (cons (algorithm (car args) (cadr args))
                           (cddr args))))))

(define (make-list len . fill)
  (assert (positive? len))
  (let iter ((k 0) (fill (if (null? fill) null (car fill))))
    (if (< k len)
      (cons fill (iter (+ k 1) fill))
      null)))

# PORTS

(define (open-input-file str)
  (port str "r"))

(define (open-binary-input-file str)
  (port str "rb"))

(define (open-output-file str)
  (port str "w"))

(define (open-binary-output-file str)
  (port str "wb"))

# STRINGS

(define (string->list str)
  (let iter ((k 0) (len (string-length str)))
    (if (< k len)
      (cons (string-ref str k)
            (iter (+ k 1) len))
      null)))

(define (list->string lst)
  (let iter ((lst lst) (str (make-string (length lst))) (k 0))
    (if (null? lst)
      str
      (begin (string-set! str k (car lst))
             (iter (cdr lst) str (+ k 1))))))

(define (string-copy str)
  (substring str 0 (string-length str)))

(define (string-reverse str)
  (list->string (reverse (string->list str))))

(define (substring str start end)
  (let* ((len (- end start))
         (sub (make-string len)))
    (let iter ((k 0))
      (cond ((< k len)
             (string-set! sub k (string-ref str (+ start k)))
             (iter (+ k 1)))
            (else sub)))))

# VECTORS

(define (vector->list vec)
  (if (not (vector? vec))
    (error `vector->list "arg must be a vector" vec))
  (let iter ((k 0))
    (if (= k (vector-length vec))
      null
      (cons (vector-ref vec k) (iter (+ k 1))))))

(define (list->vector lst)
  (if (not (list? lst))
    (error `list->vector "arg must be a list" lst))
  (apply vector lst))

(define (vector-fill! vec fill)
  (if (not (vector? vec))
    (error `vector-fill! "arg1 must be a vector" vec))
  (let ((len (vector-length vec)))
    (let iter ((k 0))
      (if (< k len)
        (begin (vector-set! vec k fill)
               (iter (+ k 1)))
        vec))))

(define (map f x . ys)
  (if (null? x)
    null
    (cons (apply f (cons (car x) (map car ys)))
          (apply map (cons* f (cdr x) (map cdr ys))))))

(define (for-each f x . ys)
  (apply map (cons* f x ys))
  null)
